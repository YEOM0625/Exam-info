# 소프트웨어 아키텍처
## 소프트웨어 아키텍처의 특징
- 간락성, 추상화, 가시성, 관점 모형, 의사소통 수단
## 구성요소
- 아키텍처 명세서, 아해관계자, 관심사, 관점(Viewpoint), 뷰(View)
## 소프트웨어 아키텍처 4+1
### 4+1 뷰 개념
- 목적
  - 고객의 요구사항을 정리한 시나리오를 다양한 관점에서 분석하고 표현.
- 적용
  - 복잡한 소프트웨어 아키텍처를 여러 이해관계자가 이해할 수 있도록 함. 

### View Model과 구성요소
- 논리적 관점(뷰)
- 구현 관점
- 프로세스 관점
- 배치 관점
- => 전체를 아우르는 **Use case 관점**(사용자 관점)

## 소프트웨어 아키텍처 품질 속성
- 정확성
- 신뢰성
- 효율성
- 무결성
- 사용 용이성
- 유지보수성
- 시험 용이성
- 유연성
- 이식성
- 재사용성
- 상호 운용성
- 확장성
- 보안

## 소프트웨어 아키텍처 패턴
### 소프트웨어 아키텍처 패턴의 중요성
- 재사용성, 표준화, 개발 효율성, 문서화

### 종류
- 계층화 패턴(Layered Pattern)
  - 정의
    - 소프트웨어를 여러계층으로 구분하여 각 계층이 하위 계층의 기능을 사용하도록 하는 구조
  - 적용
    - OSI 7계층, TCP/IP 4계층 등 네트워크 프로토콜 스택에서 널리 사용
  - 장점
    - 계층간의 독립성으로 인해 유지보수와 업그레이드 용이
    
- 클라이언트-서버 패턴(Client-Server Pattern)
  - 정의
    - 서버가 여러 클라이언트에 서비스를 제공
  - 적용
    - 대부분의 웹 애플리케이션과 DB시스템에서 사용 
  - 장점     
    - 중앙 집중식 데이터 관리와 자원의 효율적인 활용 가능  

- 마스터-슬레이브 패턴(Maseter-Slave Pattern)
  - 정의
    - 마스터 컴포넌트가 작업을 여러 슬레이브에 분산시키고 슬레이브의 처리 결과를 **종합**하는 구조 
  - 적용
    - 병렬 컴퓨팅, 고성능 컴퓨팅 환경에서 사용 
  - 장점  
    - 복잡한 작업을 여러 컴포넌트가 분담하여 처리 속도 향상이 가능 

- **파이프-필터 패턴**(Pipe-Filter Pattern)
  - 정의
    - 옆으로 전달하는 구조 
  - 적용
    - Unix 쉘 스크립트 및 데이터 스트림 처리 시스템에 사용 
  - 장점 
    - 각 필터의 독립적인 처리로 확장성과 재사용성이 높음 

- 브로커 패턴(Borker Pattern)
  - 적용
    - 분산 시스템에서 컴포넌트 간의 통신을 중재하는 브로커 컴포넌트 사용
  - 기능
    - 브로커가 서비스 요청 수신 후, 적절한 서비스를 제공자에게 전달
  - 장점 
    - 시스템의 유연성과 확장성 증진

- 피어 투 피어 패턴(Peer to Peer Pattern)
  - 정의
    - 모든 컴포넌트(피어)가 서버와 클라이언트의 역할을 동시에 수행 
  - 적용
    - 파일 공유 시스템 
  - 장점
    - 중앙 집중식 서버에 의존하지 않는 분산 네트워크 구조 가능

- 이벤트-버스 패턴(Event-Bus Pattern)
  - 적용
    - 이벤트 버스를 통해 메시지를 발행, 리스너가 이를 구독
  - 사용 예
    - 알림 시스템, 메시징 시스템 등 사용
  - 장점
    - 이벤트 기반의 비동기 통신을 가능하게 함

- **모델-뷰 컨트롤러 패턴**
  - 구성
    - 모델(데이터 처리), 뷰(사용자 인터페이스), 컨트롤러(입력처리)
  - 적용
    - 웹 애플리케이션, GUI 기반 애플리케이션 등에서 널리 사용
  - 장점
    - 각 컴포넌트의 독립성으로 인해 재사용성과 확장성이 높음

- 블랙보드 패턴(Blackboard Pattern)
  - 적용
    - 해결전략이 정의되지 않은 문제에 사용

- 인터프리터 패턴(Interpreter Pattern)
  - 적용
    - 특정 프로그래밍 **언어**의 해석과 실행을 위한 컴포넌트 설계에 사용
  - 목적
    - **언어**의 문법을 정의하고 이를 해석하여 실행    
 